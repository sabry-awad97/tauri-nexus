// =============================================================================
// Auto-Generated Tauri Bindings
// =============================================================================
// This file simulates the auto-generated TypeScript bindings that Tauri
// generates from Rust types using tauri-specta or similar tools.
//
// DO NOT EDIT THIS FILE MANUALLY - it would be overwritten by the generator.
// =============================================================================

import { z } from "zod";
import {
  procedure,
  router,
  extractSubscriptionPaths,
  type SchemaContractToContract,
} from "@tauri-nexus/rpc-core";

// =============================================================================
// Zod Schemas (Generated from Rust structs)
// =============================================================================

/** User entity schema */
export const UserSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string(),
  createdAt: z.string(),
});
export type User = z.infer<typeof UserSchema>;

/** Create user input schema */
export const CreateUserInputSchema = z.object({
  name: z.string(),
  email: z.string(),
});
export type CreateUserInput = z.infer<typeof CreateUserInputSchema>;

/** Update user input schema */
export const UpdateUserInputSchema = z.object({
  id: z.number(),
  name: z.string().optional(),
  email: z.string().optional(),
});
export type UpdateUserInput = z.infer<typeof UpdateUserInputSchema>;

/** Health response schema */
export const HealthResponseSchema = z.object({
  status: z.string(),
  version: z.string(),
});
export type HealthResponse = z.infer<typeof HealthResponseSchema>;

/** Success response schema */
export const SuccessResponseSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
});
export type SuccessResponse = z.infer<typeof SuccessResponseSchema>;

// =============================================================================
// Subscription Schemas (Generated from Rust structs)
// =============================================================================

/** Counter input schema */
export const CounterInputSchema = z.object({
  start: z.number().optional(),
  maxCount: z.number().optional(),
  intervalMs: z.number().optional(),
});
export type CounterInput = z.infer<typeof CounterInputSchema>;

/** Counter event schema */
export const CounterEventSchema = z.object({
  count: z.number(),
  timestamp: z.string(),
});
export type CounterEvent = z.infer<typeof CounterEventSchema>;

/** Chat room input schema */
export const ChatRoomInputSchema = z.object({
  roomId: z.string(),
});
export type ChatRoomInput = z.infer<typeof ChatRoomInputSchema>;

/** Chat message schema */
export const ChatMessageSchema = z.object({
  id: z.string(),
  roomId: z.string(),
  userId: z.string(),
  text: z.string(),
  timestamp: z.string(),
});
export type ChatMessage = z.infer<typeof ChatMessageSchema>;

/** Send message input schema */
export const SendMessageInputSchema = z.object({
  roomId: z.string(),
  text: z.string(),
});
export type SendMessageInput = z.infer<typeof SendMessageInputSchema>;

/** Stock input schema */
export const StockInputSchema = z.object({
  symbols: z.array(z.string()),
});
export type StockInput = z.infer<typeof StockInputSchema>;

/** Stock price schema */
export const StockPriceSchema = z.object({
  symbol: z.string(),
  price: z.number(),
  change: z.number(),
  changePercent: z.number(),
  timestamp: z.string(),
});
export type StockPrice = z.infer<typeof StockPriceSchema>;

/** Chat history input schema */
export const ChatHistoryInputSchema = z.object({
  roomId: z.string(),
  limit: z.number().optional(),
});
export type ChatHistoryInput = z.infer<typeof ChatHistoryInputSchema>;

// =============================================================================
// RPC Contract Schema (Generated from Rust router definition)
// =============================================================================

/**
 * Application RPC Contract Schema - Generated from Rust router macros.
 * Uses Zod schemas for runtime validation and type inference.
 */
export const appContractSchema = router({
  health: procedure().output(HealthResponseSchema).query(),
  greet: procedure()
    .input(z.object({ name: z.string() }))
    .output(z.string())
    .query(),

  user: router({
    get: procedure()
      .input(z.object({ id: z.number() }))
      .output(UserSchema)
      .query(),
    list: procedure().output(z.array(UserSchema)).query(),
    create: procedure()
      .input(CreateUserInputSchema)
      .output(UserSchema)
      .mutation(),
    update: procedure()
      .input(UpdateUserInputSchema)
      .output(UserSchema)
      .mutation(),
    delete: procedure()
      .input(z.object({ id: z.number() }))
      .output(SuccessResponseSchema)
      .mutation(),
  }),

  stream: router({
    counter: procedure()
      .input(CounterInputSchema)
      .output(CounterEventSchema)
      .subscription(),
    stocks: procedure()
      .input(StockInputSchema)
      .output(StockPriceSchema)
      .subscription(),
    chat: procedure()
      .input(ChatRoomInputSchema)
      .output(ChatMessageSchema)
      .subscription(),
    time: procedure().output(z.string()).subscription(),
  }),

  chat: router({
    send: procedure()
      .input(SendMessageInputSchema)
      .output(ChatMessageSchema)
      .mutation(),
    history: procedure()
      .input(ChatHistoryInputSchema)
      .output(z.array(ChatMessageSchema))
      .query(),
  }),
});

/** Inferred contract type from schema */
export type AppContract = SchemaContractToContract<typeof appContractSchema>;

// =============================================================================
// Dynamic Subscription Path Extraction
// =============================================================================

/** Dynamically extracted subscription paths from the contract schema */
export const SUBSCRIPTION_PATHS = extractSubscriptionPaths(
  appContractSchema,
) as readonly string[];

// =============================================================================
// Event Types (Generated from Tauri events)
// =============================================================================

export type EventPayload<T> = {
  payload: T;
};

export const Events = {
  COUNTER_TICK: "counter:tick",
  STOCK_UPDATE: "stock:update",
  CHAT_MESSAGE: "chat:message",
  TIME_UPDATE: "time:update",
} as const;

export type EventName = (typeof Events)[keyof typeof Events];
