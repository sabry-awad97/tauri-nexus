// =============================================================================
// Auto-Generated Tauri Bindings
// =============================================================================
// This file simulates the auto-generated TypeScript bindings that Tauri
// generates from Rust types using tauri-specta or similar tools.
//
// DO NOT EDIT THIS FILE MANUALLY - it would be overwritten by the generator.
// =============================================================================

import { z } from "zod";
import {
  procedure,
  router,
  extractEvents,
  type SchemaContractToContract,
  type InferEventName,
} from "@tauri-nexus/rpc-core";

// Import schemas for use in contract definition
import {
  UserSchema,
  CreateUserInputSchema,
  UpdateUserInputSchema,
  HealthResponseSchema,
  CounterInputSchema,
  CounterEventSchema,
  ChatRoomInputSchema,
  ChatMessageSchema,
  SendMessageInputSchema,
  StockInputSchema,
  StockPriceSchema,
} from "./schemas";

// =============================================================================
// Additional Schemas (Not in Rust types)
// =============================================================================

/** Success response schema */
export const SuccessResponseSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
});
export type SuccessResponse = z.infer<typeof SuccessResponseSchema>;

/** Chat history input schema */
export const ChatHistoryInputSchema = z.object({
  roomId: z.string(),
  limit: z.number().optional(),
});
export type ChatHistoryInput = z.infer<typeof ChatHistoryInputSchema>;

// =============================================================================
// RPC Contract Schema (Generated from Rust router definition)
// =============================================================================

/**
 * Application RPC Contract Schema - Generated from Rust router macros.
 * Uses Zod schemas for runtime validation and type inference.
 */
export const appContractSchema = router({
  health: procedure().output(HealthResponseSchema).query(),
  greet: procedure()
    .input(z.object({ name: z.string() }))
    .output(z.string())
    .query(),

  user: router({
    get: procedure()
      .input(z.object({ id: z.number() }))
      .output(UserSchema)
      .query(),
    list: procedure().output(z.array(UserSchema)).query(),
    create: procedure()
      .input(CreateUserInputSchema)
      .output(UserSchema)
      .mutation(),
    update: procedure()
      .input(UpdateUserInputSchema)
      .output(UserSchema)
      .mutation(),
    delete: procedure()
      .input(z.object({ id: z.number() }))
      .output(SuccessResponseSchema)
      .mutation(),
  }),

  stream: router({
    counter: procedure()
      .input(CounterInputSchema)
      .output(CounterEventSchema)
      .subscription(),
    stocks: procedure()
      .input(StockInputSchema)
      .output(StockPriceSchema)
      .subscription(),
    chat: procedure()
      .input(ChatRoomInputSchema)
      .output(ChatMessageSchema)
      .subscription(),
    time: procedure().output(z.string()).subscription(),
  }),

  chat: router({
    send: procedure()
      .input(SendMessageInputSchema)
      .output(ChatMessageSchema)
      .mutation(),
    history: procedure()
      .input(ChatHistoryInputSchema)
      .output(z.array(ChatMessageSchema))
      .query(),
  }),
});

/** Inferred contract type from schema */
export type AppContract = SchemaContractToContract<typeof appContractSchema>;

// =============================================================================
// Event Types (Extracted from Schema Subscriptions)
// =============================================================================

/** Event names extracted from subscription paths in the contract */
export const Events = extractEvents(appContractSchema);

/** Union type of all event names */
export type EventName = InferEventName<typeof Events>;
