// =============================================================================
// Tauri RPC Client - Core Types
// =============================================================================
// A fully type-safe RPC client library for Tauri v2 applications.
// Define your contract once, get full type safety everywhere.

// =============================================================================
// Error Types
// =============================================================================

/**
 * Standard RPC error codes matching the Rust backend.
 *
 * Backend codes (from Rust RpcErrorCode):
 * - BAD_REQUEST, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, VALIDATION_ERROR,
 *   CONFLICT, PAYLOAD_TOO_LARGE (client errors)
 * - INTERNAL_ERROR, NOT_IMPLEMENTED, SERVICE_UNAVAILABLE (server errors)
 * - PROCEDURE_NOT_FOUND, SUBSCRIPTION_ERROR, MIDDLEWARE_ERROR, SERIALIZATION_ERROR (RPC-specific)
 *
 * Client-only codes (generated by TypeScript client):
 * - TIMEOUT: Request exceeded timeout
 * - CANCELLED: Request was cancelled via AbortSignal
 * - UNKNOWN: Unrecognized error format
 */
export type RpcErrorCode =
  // Client errors (4xx equivalent) - from backend
  | "BAD_REQUEST"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "VALIDATION_ERROR"
  | "CONFLICT"
  | "PAYLOAD_TOO_LARGE"
  // Server errors (5xx equivalent) - from backend
  | "INTERNAL_ERROR"
  | "NOT_IMPLEMENTED"
  | "SERVICE_UNAVAILABLE"
  // RPC-specific errors - from backend
  | "PROCEDURE_NOT_FOUND"
  | "SUBSCRIPTION_ERROR"
  | "MIDDLEWARE_ERROR"
  | "SERIALIZATION_ERROR"
  // Client-only codes
  | "TIMEOUT"
  | "CANCELLED"
  | "UNKNOWN";

/**
 * RPC Error structure matching Rust RpcError.
 *
 * The backend serializes errors as:
 * ```json
 * {
 *   "code": "NOT_FOUND",
 *   "message": "User not found",
 *   "details": { "userId": 123 },  // optional
 *   "cause": "Database query returned empty"  // optional, debug only
 * }
 * ```
 */
export interface RpcError {
  /** Error code - either a standard RpcErrorCode or custom string */
  code: RpcErrorCode | string;
  /** Human-readable error message */
  message: string;
  /** Optional additional details (JSON value from backend) */
  details?: unknown;
  /** Optional cause for debugging (may be stripped in production) */
  cause?: string;
}

// =============================================================================
// Event Types
// =============================================================================

/** Event with optional metadata for streaming */
export interface Event<T> {
  data: T;
  id?: string;
  retry?: number;
}

/** Event metadata for SSE-style streaming */
export interface EventMeta {
  id?: string;
  retry?: number;
}

// =============================================================================
// Batch Request Types
// =============================================================================

/**
 * A single request within a batch.
 * Matches the Rust SingleRequest struct.
 */
export interface SingleRequest {
  /** Unique identifier for this request within the batch */
  id: string;
  /** The procedure path to call (e.g., "user.get", "post.create") */
  path: string;
  /** Input data for the procedure */
  input: unknown;
}

/**
 * A batch of RPC requests to be processed together.
 * Matches the Rust BatchRequest struct.
 */
export interface BatchRequest {
  /** The list of requests to process */
  requests: SingleRequest[];
}

/**
 * Result of a single request within a batch.
 * Contains either the successful result or an error.
 */
export interface BatchResult<T = unknown> {
  /** The ID of the request this result corresponds to */
  id: string;
  /** The result data (present on success) */
  data?: T;
  /** The error (present on failure) */
  error?: RpcError;
}

/**
 * Response containing results for all requests in a batch.
 * Matches the Rust BatchResponse struct.
 */
export interface BatchResponse<T = unknown> {
  /** Results for each request, in the same order as the input requests */
  results: BatchResult<T>[];
}

/**
 * Options for batch calls.
 */
export interface BatchCallOptions {
  /** Abort signal for cancellation */
  signal?: AbortSignal;
  /** Request timeout in milliseconds (applies to entire batch) */
  timeout?: number;
  /** Custom headers/metadata */
  meta?: Record<string, unknown>;
}

// =============================================================================
// Type-Safe Batch Types
// =============================================================================

/**
 * Helper to check if a type is a callable (non-subscription) procedure
 */
type IsCallableProcedure<T> = T extends {
  type: "query" | "mutation";
  input: unknown;
  output: unknown;
}
  ? true
  : false;

/**
 * Helper to get known keys (excluding index signatures)
 */
type KnownKeys<T> = {
  [K in keyof T]: string extends K ? never : number extends K ? never : K;
}[keyof T];

/**
 * Extract all callable (non-subscription) procedure paths from a contract.
 * Subscriptions cannot be batched.
 *
 * This type extracts paths up to 3 levels deep and handles contracts with index signatures.
 */
export type ExtractCallablePaths<T> = T extends object
  ? {
      [K in KnownKeys<T>]: K extends string
        ? // Check if it's a callable procedure at this level
          IsCallableProcedure<T[K]> extends true
          ? K
          : // Otherwise, check nested levels
            T[K] extends object
            ? T[K] extends {
                type: ProcedureType;
                input: unknown;
                output: unknown;
              }
              ? never // It's a subscription, skip
              : {
                  [K2 in KnownKeys<T[K]>]: K2 extends string
                    ? IsCallableProcedure<T[K][K2]> extends true
                      ? `${K}.${K2}`
                      : T[K][K2] extends object
                        ? T[K][K2] extends {
                            type: ProcedureType;
                            input: unknown;
                            output: unknown;
                          }
                          ? never
                          : {
                              [K3 in KnownKeys<T[K][K2]>]: K3 extends string
                                ? IsCallableProcedure<T[K][K2][K3]> extends true
                                  ? `${K}.${K2}.${K3}`
                                  : never
                                : never;
                            }[KnownKeys<T[K][K2]>]
                        : never
                    : never;
                }[KnownKeys<T[K]>]
            : never
        : never;
    }[KnownKeys<T>]
  : never;

/**
 * Get the input type for a procedure at a given path.
 * Supports up to 3 levels of nesting.
 */
export type GetInputAtPath<
  T,
  Path extends string,
> = Path extends `${infer L1}.${infer L2}.${infer L3}`
  ? L1 extends keyof T
    ? T[L1] extends object
      ? L2 extends keyof T[L1]
        ? T[L1][L2] extends object
          ? L3 extends keyof T[L1][L2]
            ? T[L1][L2][L3] extends {
                type: ProcedureType;
                input: infer I;
                output: unknown;
              }
              ? I
              : never
            : never
          : never
        : never
      : never
    : never
  : Path extends `${infer L1}.${infer L2}`
    ? L1 extends keyof T
      ? T[L1] extends object
        ? L2 extends keyof T[L1]
          ? T[L1][L2] extends {
              type: ProcedureType;
              input: infer I;
              output: unknown;
            }
            ? I
            : never
          : never
        : never
      : never
    : Path extends keyof T
      ? T[Path] extends { type: ProcedureType; input: infer I; output: unknown }
        ? I
        : never
      : never;

/**
 * Get the output type for a procedure at a given path.
 * Supports up to 3 levels of nesting.
 */
export type GetOutputAtPath<
  T,
  Path extends string,
> = Path extends `${infer L1}.${infer L2}.${infer L3}`
  ? L1 extends keyof T
    ? T[L1] extends object
      ? L2 extends keyof T[L1]
        ? T[L1][L2] extends object
          ? L3 extends keyof T[L1][L2]
            ? T[L1][L2][L3] extends {
                type: ProcedureType;
                input: unknown;
                output: infer O;
              }
              ? O
              : never
            : never
          : never
        : never
      : never
    : never
  : Path extends `${infer L1}.${infer L2}`
    ? L1 extends keyof T
      ? T[L1] extends object
        ? L2 extends keyof T[L1]
          ? T[L1][L2] extends {
              type: ProcedureType;
              input: unknown;
              output: infer O;
            }
            ? O
            : never
          : never
        : never
      : never
    : Path extends keyof T
      ? T[Path] extends { type: ProcedureType; input: unknown; output: infer O }
        ? O
        : never
      : never;

/**
 * Type-safe single request for a specific contract.
 * The path is constrained to valid callable paths, and input is inferred.
 */
export interface TypedSingleRequest<
  TContract,
  TPath extends ExtractCallablePaths<TContract> =
    ExtractCallablePaths<TContract>,
> {
  /** Unique identifier for this request within the batch */
  id: string;
  /** The procedure path - constrained to valid paths from the contract */
  path: TPath;
  /** Input data - type is inferred from the path */
  input: GetInputAtPath<TContract, TPath>;
}

/**
 * Type-safe batch result that preserves the output type based on the request.
 */
export interface TypedBatchResult<TOutput = unknown> {
  /** The ID of the request this result corresponds to */
  id: string;
  /** The result data (present on success) */
  data?: TOutput;
  /** The error (present on failure) */
  error?: RpcError;
}

/**
 * Helper type to create a request entry for the batch builder.
 * Maps request ID to its expected output type.
 */
export type BatchRequestEntry<TId extends string, TOutput> = {
  id: TId;
  output: TOutput;
};

/**
 * Extract output type from a batch request entries tuple.
 */
export type ExtractBatchOutputs<
  T extends readonly BatchRequestEntry<string, unknown>[],
> = {
  [K in T[number]["id"]]: Extract<T[number], { id: K }>["output"];
};

/**
 * Type-safe batch response with results typed per request ID.
 */
export interface TypedBatchResponseType<
  TEntries extends readonly BatchRequestEntry<string, unknown>[],
> {
  results: {
    [K in keyof TEntries]: TEntries[K] extends BatchRequestEntry<
      infer Id,
      infer Output
    >
      ? TypedBatchResult<Output> & { id: Id }
      : never;
  };
}

/**
 * Helper to create a typed request object.
 * This is used internally by the TypedBatchBuilder.
 */
export type CreateTypedRequest<
  TContract,
  TPath extends ExtractCallablePaths<TContract>,
  TId extends string,
> = {
  id: TId;
  path: TPath;
  input: GetInputAtPath<TContract, TPath>;
  _output: GetOutputAtPath<TContract, TPath>;
};

// =============================================================================
// Procedure Definition Types
// =============================================================================

/** Procedure types */
export type ProcedureType = "query" | "mutation" | "subscription";

/** Base procedure definition */
export interface ProcedureDef<
  TType extends ProcedureType = ProcedureType,
  TInput = unknown,
  TOutput = unknown,
> {
  readonly _type: TType;
  readonly _input: TInput;
  readonly _output: TOutput;
}

/** Query procedure - for reading data */
export interface QueryDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"query", TInput, TOutput> {}

/** Mutation procedure - for writing data */
export interface MutationDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"mutation", TInput, TOutput> {}

/** Subscription procedure - for streaming data */
export interface SubscriptionDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"subscription", TInput, TOutput> {}

// =============================================================================
// Contract Router Types
// =============================================================================

/** Base procedure definition for contract */
export type ProcedureDefinition = {
  type: ProcedureType;
  input: unknown;
  output: unknown;
};

/** Check if a type is a procedure definition */
export type IsProcedure<T> = T extends ProcedureDef ? true : false;

/** Check if a type is a router (nested object with procedures) */
export type IsRouter<T> = T extends object
  ? T extends ProcedureDef
    ? false
    : true
  : false;

// =============================================================================
// Type Inference Utilities
// =============================================================================

/** Extract input type from procedure */
export type InferInput<T> =
  T extends ProcedureDef<any, infer I, any> ? I : never;

/** Extract output type from procedure */
export type InferOutput<T> =
  T extends ProcedureDef<any, any, infer O> ? O : never;

/** Extract procedure type */
export type InferProcedureType<T> =
  T extends ProcedureDef<infer P, any, any> ? P : never;

/** Check if procedure is a query */
export type IsQuery<T> = T extends QueryDef<any, any> ? true : false;

/** Check if procedure is a mutation */
export type IsMutation<T> = T extends MutationDef<any, any> ? true : false;

/** Check if procedure is a subscription */
export type IsSubscription<T> =
  T extends SubscriptionDef<any, any> ? true : false;

// =============================================================================
// Event Iterator Types
// =============================================================================

/** Async event iterator for subscriptions */
export interface EventIterator<T> extends AsyncIterable<T> {
  /** Stop the stream and clean up resources */
  return(): Promise<void>;
  /** Get the underlying async iterator */
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// =============================================================================
// Call Options
// =============================================================================

/** Options for query/mutation calls */
export interface CallOptions {
  /** Abort signal for cancellation */
  signal?: AbortSignal;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Custom headers/metadata */
  meta?: Record<string, unknown>;
}

/** Options for subscription calls */
export interface SubscriptionOptions extends CallOptions {
  /** Last event ID for resumption */
  lastEventId?: string;
  /** Auto-reconnect on disconnect */
  autoReconnect?: boolean;
  /** Reconnect delay in milliseconds */
  reconnectDelay?: number;
  /** Maximum reconnect attempts */
  maxReconnects?: number;
}

// =============================================================================
// Client Method Types
// =============================================================================

/** Input type handling - void inputs don't require arguments */
type InputArg<TInput> = TInput extends void | undefined | never
  ? []
  : [input: TInput];

/** Options argument type */
type OptionsArg<TOptions> = [options?: TOptions];

/** Convert procedure def to client method signature */
export type ProcedureClient<T> = T extends {
  type: "subscription";
  input: infer I;
  output: infer O;
}
  ? (
      ...args: [...InputArg<I>, ...OptionsArg<SubscriptionOptions>]
    ) => Promise<EventIterator<O>>
  : T extends { type: "query" | "mutation"; input: infer I; output: infer O }
    ? (...args: [...InputArg<I>, ...OptionsArg<CallOptions>]) => Promise<O>
    : never;

/** Check if type is a procedure definition */
type IsProcedureDefinition<T> = T extends {
  type: ProcedureType;
  input: unknown;
  output: unknown;
}
  ? true
  : false;

/** Convert contract router to client type recursively */
export type RouterClient<T> = {
  [K in keyof T]: IsProcedureDefinition<T[K]> extends true
    ? ProcedureClient<T[K]>
    : T[K] extends object
      ? RouterClient<T[K]>
      : never;
};

// =============================================================================
// Path Extraction Types
// =============================================================================

/** Check if type is a procedure definition (internal helper) */
type IsProcedureType<T> = T extends {
  type: ProcedureType;
  input: unknown;
  output: unknown;
}
  ? true
  : false;

/** Extract all procedure paths from a router */
export type ExtractPaths<T, Prefix extends string = ""> =
  IsProcedureType<T> extends true
    ? Prefix
    : T extends object
      ? {
          [K in keyof T]: K extends string
            ? ExtractPaths<T[K], Prefix extends "" ? K : `${Prefix}.${K}`>
            : never;
        }[keyof T]
      : never;

/** Extract subscription paths from a router */
export type ExtractSubscriptionPaths<
  T,
  Prefix extends string = "",
> = T extends { type: "subscription"; input: unknown; output: unknown }
  ? Prefix
  : T extends object
    ? {
        [K in keyof T]: K extends string
          ? ExtractSubscriptionPaths<
              T[K],
              Prefix extends "" ? K : `${Prefix}.${K}`
            >
          : never;
      }[keyof T]
    : never;

/** Get procedure at a specific path */
export type GetProcedureAtPath<
  T,
  Path extends string,
> = Path extends `${infer Head}.${infer Tail}`
  ? Head extends keyof T
    ? GetProcedureAtPath<T[Head], Tail>
    : never
  : Path extends keyof T
    ? T[Path]
    : never;

// =============================================================================
// Contract Builder Helpers
// =============================================================================

/** Define a query procedure */
export function query<TInput = void, TOutput = void>(): QueryDef<
  TInput,
  TOutput
> {
  return {
    _type: "query",
    _input: undefined as TInput,
    _output: undefined as TOutput,
  };
}

/** Define a mutation procedure */
export function mutation<TInput = void, TOutput = void>(): MutationDef<
  TInput,
  TOutput
> {
  return {
    _type: "mutation",
    _input: undefined as TInput,
    _output: undefined as TOutput,
  };
}

/** Define a subscription procedure */
export function subscription<TInput = void, TOutput = void>(): SubscriptionDef<
  TInput,
  TOutput
> {
  return {
    _type: "subscription",
    _input: undefined as TInput,
    _output: undefined as TOutput,
  };
}

// =============================================================================
// Middleware Types
// =============================================================================

/** Request context passed through middleware */
export interface RequestContext {
  path: string;
  input: unknown;
  type: ProcedureType;
  meta?: Record<string, unknown>;
  signal?: AbortSignal;
}

/** Response context from middleware */
export interface ResponseContext<T = unknown> {
  data: T;
  meta?: Record<string, unknown>;
}

/** Middleware function type */
export type Middleware = <T>(
  ctx: RequestContext,
  next: () => Promise<T>,
) => Promise<T>;

// =============================================================================
// Subscribe Request (matches Rust SubscribeRequest)
// =============================================================================

/** Subscribe request payload sent to backend */
export interface SubscribeRequest {
  id?: string;
  path: string;
  input: unknown;
  lastEventId?: string;
}

// =============================================================================
// Utility Types
// =============================================================================

/** Make all properties optional recursively */
export type DeepPartial<T> = T extends object
  ? { [P in keyof T]?: DeepPartial<T[P]> }
  : T;

/** Prettify type for better IntelliSense display */
export type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

// =============================================================================
// Client Type Inference Utilities
// =============================================================================

/**
 * Recursively infers the input types from a contract.
 * Produces a nested map where each endpoint's input type is preserved.
 *
 * @example
 * ```typescript
 * type Inputs = InferClientInputs<AppContract>;
 * type FindUserInput = Inputs['user']['get']; // { id: number }
 * ```
 */
export type InferClientInputs<T> = {
  [K in keyof T]: T[K] extends {
    type: ProcedureType;
    input: infer I;
    output: unknown;
  }
    ? I
    : T[K] extends object
      ? InferClientInputs<T[K]>
      : never;
};

/**
 * Recursively infers the output types from a contract.
 * Produces a nested map where each endpoint's output type is preserved.
 *
 * @example
 * ```typescript
 * type Outputs = InferClientOutputs<AppContract>;
 * type FindUserOutput = Outputs['user']['get']; // User
 * ```
 */
export type InferClientOutputs<T> = {
  [K in keyof T]: T[K] extends {
    type: ProcedureType;
    input: unknown;
    output: infer O;
  }
    ? O
    : T[K] extends object
      ? InferClientOutputs<T[K]>
      : never;
};

/**
 * Recursively infers the body input types from a contract.
 * If an endpoint's input includes `{ body: ... }`, only the body portion is extracted.
 *
 * @example
 * ```typescript
 * type BodyInputs = InferClientBodyInputs<AppContract>;
 * type CreateUserBody = BodyInputs['user']['create']; // { name: string; email: string }
 * ```
 */
export type InferClientBodyInputs<T> = {
  [K in keyof T]: T[K] extends {
    type: ProcedureType;
    input: infer I;
    output: unknown;
  }
    ? I extends { body: infer B }
      ? B
      : I
    : T[K] extends object
      ? InferClientBodyInputs<T[K]>
      : never;
};

/**
 * Recursively infers the body output types from a contract.
 * If an endpoint's output includes `{ body: ... }`, only the body portion is extracted.
 *
 * @example
 * ```typescript
 * type BodyOutputs = InferClientBodyOutputs<AppContract>;
 * type CreateUserBodyOutput = BodyOutputs['user']['create'];
 * ```
 */
export type InferClientBodyOutputs<T> = {
  [K in keyof T]: T[K] extends {
    type: ProcedureType;
    input: unknown;
    output: infer O;
  }
    ? O extends { body: infer B }
      ? B
      : O
    : T[K] extends object
      ? InferClientBodyOutputs<T[K]>
      : never;
};

/**
 * Recursively infers the error types from a contract.
 * Produces a nested map where each endpoint's error type is preserved.
 *
 * @example
 * ```typescript
 * type Errors = InferClientErrors<AppContract>;
 * type FindUserError = Errors['user']['get']; // RpcError
 * ```
 */
export type InferClientErrors<T> = {
  [K in keyof T]: T[K] extends {
    type: ProcedureType;
    input: unknown;
    output: unknown;
  }
    ? RpcError
    : T[K] extends object
      ? InferClientErrors<T[K]>
      : never;
};

/**
 * Recursively infers a union of all error types from a contract.
 * Useful when you want to handle all possible errors from any endpoint at once.
 *
 * @example
 * ```typescript
 * type AllErrors = InferClientErrorUnion<AppContract>; // RpcError
 * ```
 */
export type InferClientErrorUnion<T> = T extends {
  type: ProcedureType;
  input: unknown;
  output: unknown;
}
  ? RpcError
  : T extends object
    ? { [K in keyof T]: InferClientErrorUnion<T[K]> }[keyof T]
    : never;

/**
 * Infers the procedure type (query, mutation, subscription) for each endpoint.
 *
 * @example
 * ```typescript
 * type Types = InferClientProcedureTypes<AppContract>;
 * type UserGetType = Types['user']['get']; // 'query'
 * ```
 */
export type InferClientProcedureTypes<T> = {
  [K in keyof T]: T[K] extends {
    type: infer P;
    input: unknown;
    output: unknown;
  }
    ? P
    : T[K] extends object
      ? InferClientProcedureTypes<T[K]>
      : never;
};

/**
 * Extract all input types as a union from a contract.
 *
 * @example
 * ```typescript
 * type AllInputs = InferClientInputUnion<AppContract>;
 * ```
 */
export type InferClientInputUnion<T> = T extends {
  type: ProcedureType;
  input: infer I;
  output: unknown;
}
  ? I
  : T extends object
    ? { [K in keyof T]: InferClientInputUnion<T[K]> }[keyof T]
    : never;

/**
 * Extract all output types as a union from a contract.
 *
 * @example
 * ```typescript
 * type AllOutputs = InferClientOutputUnion<AppContract>;
 * ```
 */
export type InferClientOutputUnion<T> = T extends {
  type: ProcedureType;
  input: unknown;
  output: infer O;
}
  ? O
  : T extends object
    ? { [K in keyof T]: InferClientOutputUnion<T[K]> }[keyof T]
    : never;

/**
 * Infer the client context type from a client (placeholder for link-based clients).
 * For actual context inference from TauriLink, use InferLinkContext from ./link.
 *
 * @example
 * ```typescript
 * // For link-based clients, import from ./link:
 * import { InferLinkContext, InferClientContext } from './link';
 * ```
 */
export type InferClientContext<T> = T extends { __context?: infer C }
  ? C
  : unknown;
