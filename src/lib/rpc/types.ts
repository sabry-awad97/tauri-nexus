// =============================================================================
// Tauri RPC Client - Core Types
// =============================================================================
// A fully type-safe RPC client library for Tauri v2 applications.
// Define your contract once, get full type safety everywhere.

// =============================================================================
// Error Types
// =============================================================================

/**
 * Standard RPC error codes matching the Rust backend.
 * 
 * Backend codes (from Rust RpcErrorCode):
 * - BAD_REQUEST, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, VALIDATION_ERROR,
 *   CONFLICT, PAYLOAD_TOO_LARGE (client errors)
 * - INTERNAL_ERROR, NOT_IMPLEMENTED, SERVICE_UNAVAILABLE (server errors)
 * - PROCEDURE_NOT_FOUND, SUBSCRIPTION_ERROR, MIDDLEWARE_ERROR, SERIALIZATION_ERROR (RPC-specific)
 * 
 * Client-only codes (generated by TypeScript client):
 * - TIMEOUT: Request exceeded timeout
 * - CANCELLED: Request was cancelled via AbortSignal
 * - UNKNOWN: Unrecognized error format
 */
export type RpcErrorCode =
  // Client errors (4xx equivalent) - from backend
  | 'BAD_REQUEST'
  | 'UNAUTHORIZED'
  | 'FORBIDDEN'
  | 'NOT_FOUND'
  | 'VALIDATION_ERROR'
  | 'CONFLICT'
  | 'PAYLOAD_TOO_LARGE'
  // Server errors (5xx equivalent) - from backend
  | 'INTERNAL_ERROR'
  | 'NOT_IMPLEMENTED'
  | 'SERVICE_UNAVAILABLE'
  // RPC-specific errors - from backend
  | 'PROCEDURE_NOT_FOUND'
  | 'SUBSCRIPTION_ERROR'
  | 'MIDDLEWARE_ERROR'
  | 'SERIALIZATION_ERROR'
  // Client-only codes
  | 'TIMEOUT'
  | 'CANCELLED'
  | 'UNKNOWN';

/**
 * RPC Error structure matching Rust RpcError.
 * 
 * The backend serializes errors as:
 * ```json
 * {
 *   "code": "NOT_FOUND",
 *   "message": "User not found",
 *   "details": { "userId": 123 },  // optional
 *   "cause": "Database query returned empty"  // optional, debug only
 * }
 * ```
 */
export interface RpcError {
  /** Error code - either a standard RpcErrorCode or custom string */
  code: RpcErrorCode | string;
  /** Human-readable error message */
  message: string;
  /** Optional additional details (JSON value from backend) */
  details?: unknown;
  /** Optional cause for debugging (may be stripped in production) */
  cause?: string;
}

// =============================================================================
// Event Types
// =============================================================================

/** Event with optional metadata for streaming */
export interface Event<T> {
  data: T;
  id?: string;
  retry?: number;
}

/** Event metadata for SSE-style streaming */
export interface EventMeta {
  id?: string;
  retry?: number;
}

// =============================================================================
// Procedure Definition Types
// =============================================================================

/** Procedure types */
export type ProcedureType = 'query' | 'mutation' | 'subscription';

/** Base procedure definition */
export interface ProcedureDef<
  TType extends ProcedureType = ProcedureType,
  TInput = unknown,
  TOutput = unknown,
> {
  readonly _type: TType;
  readonly _input: TInput;
  readonly _output: TOutput;
}

/** Query procedure - for reading data */
export interface QueryDef<TInput = void, TOutput = unknown>
  extends ProcedureDef<'query', TInput, TOutput> {}

/** Mutation procedure - for writing data */
export interface MutationDef<TInput = void, TOutput = unknown>
  extends ProcedureDef<'mutation', TInput, TOutput> {}

/** Subscription procedure - for streaming data */
export interface SubscriptionDef<TInput = void, TOutput = unknown>
  extends ProcedureDef<'subscription', TInput, TOutput> {}

// =============================================================================
// Contract Router Types
// =============================================================================

/** Base procedure definition for contract */
export type ProcedureDefinition = {
  type: ProcedureType;
  input: unknown;
  output: unknown;
};

/** A router can contain procedures or nested routers */
export type ContractRouter = {
  [key: string]: ProcedureDefinition | ContractRouter;
};

/** Check if a type is a procedure definition */
export type IsProcedure<T> = T extends ProcedureDef ? true : false;

/** Check if a type is a router */
export type IsRouter<T> = T extends ContractRouter
  ? T extends ProcedureDef
    ? false
    : true
  : false;

// =============================================================================
// Type Inference Utilities
// =============================================================================

/** Extract input type from procedure */
export type InferInput<T> = T extends ProcedureDef<any, infer I, any> ? I : never;

/** Extract output type from procedure */
export type InferOutput<T> = T extends ProcedureDef<any, any, infer O> ? O : never;

/** Extract procedure type */
export type InferProcedureType<T> = T extends ProcedureDef<infer P, any, any> ? P : never;

/** Check if procedure is a query */
export type IsQuery<T> = T extends QueryDef<any, any> ? true : false;

/** Check if procedure is a mutation */
export type IsMutation<T> = T extends MutationDef<any, any> ? true : false;

/** Check if procedure is a subscription */
export type IsSubscription<T> = T extends SubscriptionDef<any, any> ? true : false;

// =============================================================================
// Event Iterator Types
// =============================================================================

/** Async event iterator for subscriptions */
export interface EventIterator<T> extends AsyncIterable<T> {
  /** Stop the stream and clean up resources */
  return(): Promise<void>;
  /** Get the underlying async iterator */
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// =============================================================================
// Call Options
// =============================================================================

/** Options for query/mutation calls */
export interface CallOptions {
  /** Abort signal for cancellation */
  signal?: AbortSignal;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** Custom headers/metadata */
  meta?: Record<string, unknown>;
}

/** Options for subscription calls */
export interface SubscriptionOptions extends CallOptions {
  /** Last event ID for resumption */
  lastEventId?: string;
  /** Auto-reconnect on disconnect */
  autoReconnect?: boolean;
  /** Reconnect delay in milliseconds */
  reconnectDelay?: number;
  /** Maximum reconnect attempts */
  maxReconnects?: number;
}

// =============================================================================
// Client Method Types
// =============================================================================

/** Input type handling - void inputs don't require arguments */
type InputArg<TInput> = TInput extends void | undefined | never
  ? []
  : [input: TInput];

/** Options argument type */
type OptionsArg<TOptions> = [options?: TOptions];

/** Convert procedure def to client method signature */
export type ProcedureClient<T> =
  T extends { type: 'subscription'; input: infer I; output: infer O }
    ? (...args: [...InputArg<I>, ...OptionsArg<SubscriptionOptions>]) => Promise<EventIterator<O>>
    : T extends { type: 'query' | 'mutation'; input: infer I; output: infer O }
      ? (...args: [...InputArg<I>, ...OptionsArg<CallOptions>]) => Promise<O>
      : never;

/** Check if type is a procedure definition */
type IsProcedureDefinition<T> = T extends { type: ProcedureType; input: unknown; output: unknown } ? true : false;

/** Convert contract router to client type recursively */
export type RouterClient<T> = {
  [K in keyof T]: IsProcedureDefinition<T[K]> extends true
    ? ProcedureClient<T[K]>
    : T[K] extends object
      ? RouterClient<T[K]>
      : never;
};

// =============================================================================
// Path Extraction Types
// =============================================================================

/** Check if type is a procedure definition (internal helper) */
type IsProcedureType<T> = T extends { type: ProcedureType; input: unknown; output: unknown } ? true : false;

/** Extract all procedure paths from a router */
export type ExtractPaths<T, Prefix extends string = ''> = 
  IsProcedureType<T> extends true
    ? Prefix
    : T extends object
      ? {
          [K in keyof T]: K extends string
            ? ExtractPaths<T[K], Prefix extends '' ? K : `${Prefix}.${K}`>
            : never;
        }[keyof T]
      : never;

/** Extract subscription paths from a router */
export type ExtractSubscriptionPaths<T, Prefix extends string = ''> =
  T extends { type: 'subscription'; input: unknown; output: unknown }
    ? Prefix
    : T extends object
      ? {
          [K in keyof T]: K extends string
            ? ExtractSubscriptionPaths<T[K], Prefix extends '' ? K : `${Prefix}.${K}`>
            : never;
        }[keyof T]
      : never;

/** Get procedure at a specific path */
export type GetProcedureAtPath<T, Path extends string> =
  Path extends `${infer Head}.${infer Tail}`
    ? Head extends keyof T
      ? GetProcedureAtPath<T[Head], Tail>
      : never
    : Path extends keyof T
      ? T[Path]
      : never;

// =============================================================================
// Contract Builder Helpers
// =============================================================================

/** Define a query procedure */
export function query<TInput = void, TOutput = void>(): QueryDef<TInput, TOutput> {
  return { _type: 'query', _input: undefined as TInput, _output: undefined as TOutput };
}

/** Define a mutation procedure */
export function mutation<TInput = void, TOutput = void>(): MutationDef<TInput, TOutput> {
  return { _type: 'mutation', _input: undefined as TInput, _output: undefined as TOutput };
}

/** Define a subscription procedure */
export function subscription<TInput = void, TOutput = void>(): SubscriptionDef<TInput, TOutput> {
  return { _type: 'subscription', _input: undefined as TInput, _output: undefined as TOutput };
}

// =============================================================================
// Middleware Types
// =============================================================================

/** Request context passed through middleware */
export interface RequestContext {
  path: string;
  input: unknown;
  type: ProcedureType;
  meta?: Record<string, unknown>;
  signal?: AbortSignal;
}

/** Response context from middleware */
export interface ResponseContext<T = unknown> {
  data: T;
  meta?: Record<string, unknown>;
}

/** Middleware function type */
export type Middleware = <T>(
  ctx: RequestContext,
  next: () => Promise<T>
) => Promise<T>;

// =============================================================================
// Subscribe Request (matches Rust SubscribeRequest)
// =============================================================================

/** Subscribe request payload sent to backend */
export interface SubscribeRequest {
  id?: string;
  path: string;
  input: unknown;
  lastEventId?: string;
}

// =============================================================================
// Utility Types
// =============================================================================

/** Make all properties optional recursively */
export type DeepPartial<T> = T extends object
  ? { [P in keyof T]?: DeepPartial<T[P]> }
  : T;

/** Prettify type for better IntelliSense display */
export type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};
