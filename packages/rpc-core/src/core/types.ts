// =============================================================================
// @tauri-nexus/rpc-core - Core Domain Types
// =============================================================================
// Pure TypeScript types with no external dependencies.
// These types form the foundation of the RPC system.

// =============================================================================
// Error Types
// =============================================================================

/**
 * Standard RPC error codes matching the Rust backend.
 *
 * Backend codes (from Rust RpcErrorCode):
 * - BAD_REQUEST, UNAUTHORIZED, FORBIDDEN, NOT_FOUND, VALIDATION_ERROR,
 *   CONFLICT, PAYLOAD_TOO_LARGE, RATE_LIMITED (client errors)
 * - INTERNAL_ERROR, NOT_IMPLEMENTED, SERVICE_UNAVAILABLE (server errors)
 * - PROCEDURE_NOT_FOUND, SUBSCRIPTION_ERROR, MIDDLEWARE_ERROR, SERIALIZATION_ERROR (RPC-specific)
 *
 * Client-only codes (generated by TypeScript client):
 * - TIMEOUT: Request exceeded timeout
 * - CANCELLED: Request was cancelled via AbortSignal
 * - UNKNOWN: Unrecognized error format
 */
export type RpcErrorCode =
  // Client errors (4xx equivalent) - from backend
  | "BAD_REQUEST"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "VALIDATION_ERROR"
  | "CONFLICT"
  | "PAYLOAD_TOO_LARGE"
  | "RATE_LIMITED"
  // Server errors (5xx equivalent) - from backend
  | "INTERNAL_ERROR"
  | "NOT_IMPLEMENTED"
  | "SERVICE_UNAVAILABLE"
  // RPC-specific errors - from backend
  | "PROCEDURE_NOT_FOUND"
  | "SUBSCRIPTION_ERROR"
  | "MIDDLEWARE_ERROR"
  | "SERIALIZATION_ERROR"
  // Client-only codes
  | "TIMEOUT"
  | "CANCELLED"
  | "UNKNOWN";

/**
 * RPC Error structure matching Rust RpcError.
 */
export interface RpcError {
  /** Error code - either a standard RpcErrorCode or custom string */
  readonly code: RpcErrorCode | string;
  /** Human-readable error message */
  readonly message: string;
  /** Optional additional details (JSON value from backend) */
  readonly details?: unknown;
  /** Optional cause for debugging (may be stripped in production) */
  readonly cause?: string;
}

// =============================================================================
// Procedure Types
// =============================================================================

/** Procedure types */
export type ProcedureType = "query" | "mutation" | "subscription";

/** Base procedure definition */
export interface ProcedureDef<
  TType extends ProcedureType = ProcedureType,
  TInput = unknown,
  TOutput = unknown,
> {
  readonly _type: TType;
  readonly _input: TInput;
  readonly _output: TOutput;
}

/** Query procedure - for reading data */
export interface QueryDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"query", TInput, TOutput> {}

/** Mutation procedure - for writing data */
export interface MutationDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"mutation", TInput, TOutput> {}

/** Subscription procedure - for streaming data */
export interface SubscriptionDef<
  TInput = void,
  TOutput = unknown,
> extends ProcedureDef<"subscription", TInput, TOutput> {}

// =============================================================================
// Contract Types
// =============================================================================

/** Base procedure definition for contract */
export type ProcedureDefinition = {
  type: ProcedureType;
  input: unknown;
  output: unknown;
};

/** Check if a type is a procedure definition */
export type IsProcedure<T> = T extends ProcedureDef ? true : false;

/** Check if a type is a router (nested object with procedures) */
export type IsRouter<T> = T extends object
  ? T extends ProcedureDef
    ? false
    : true
  : false;

// =============================================================================
// Event Types
// =============================================================================

/** Event with optional metadata for streaming */
export interface Event<T> {
  readonly data: T;
  readonly id?: string;
  readonly retry?: number;
}

/** Event metadata for SSE-style streaming */
export interface EventMeta {
  readonly id?: string;
  readonly retry?: number;
}

// =============================================================================
// Batch Request Types
// =============================================================================

/**
 * A single request within a batch.
 * Matches the Rust SingleRequest struct.
 */
export interface SingleRequest {
  /** Unique identifier for this request within the batch */
  readonly id: string;
  /** The procedure path to call (e.g., "user.get", "post.create") */
  readonly path: string;
  /** Input data for the procedure */
  readonly input: unknown;
}

/**
 * A batch of RPC requests to be processed together.
 * Matches the Rust BatchRequest struct.
 */
export interface BatchRequest {
  /** The list of requests to process */
  readonly requests: readonly SingleRequest[];
}

/**
 * Result of a single request within a batch.
 * Contains either the successful result or an error.
 */
export interface BatchResult<T = unknown> {
  /** The ID of the request this result corresponds to */
  readonly id: string;
  /** The result data (present on success) */
  readonly data?: T;
  /** The error (present on failure) */
  readonly error?: RpcError;
}

/**
 * Response containing results for all requests in a batch.
 * Matches the Rust BatchResponse struct.
 */
export interface BatchResponse<T = unknown> {
  /** Results for each request, in the same order as the input requests */
  readonly results: readonly BatchResult<T>[];
}

// =============================================================================
// Call Options
// =============================================================================

/** Options for query/mutation calls */
export interface CallOptions {
  /** Abort signal for cancellation */
  readonly signal?: AbortSignal;
  /** Request timeout in milliseconds */
  readonly timeout?: number;
  /** Custom headers/metadata */
  readonly meta?: Record<string, unknown>;
}

/** Options for subscription calls */
export interface SubscriptionOptions extends CallOptions {
  /** Last event ID for resumption */
  readonly lastEventId?: string;
  /** Auto-reconnect on disconnect */
  readonly autoReconnect?: boolean;
  /** Reconnect delay in milliseconds */
  readonly reconnectDelay?: number;
  /** Maximum reconnect attempts */
  readonly maxReconnects?: number;
}

/** Options for batch calls */
export interface BatchCallOptions {
  /** Abort signal for cancellation */
  readonly signal?: AbortSignal;
  /** Request timeout in milliseconds (applies to entire batch) */
  readonly timeout?: number;
  /** Custom headers/metadata */
  readonly meta?: Record<string, unknown>;
}

// =============================================================================
// Subscribe Request (matches Rust SubscribeRequest)
// =============================================================================

/** Subscribe request payload sent to backend */
export interface SubscribeRequest {
  readonly id?: string;
  readonly path: string;
  readonly input: unknown;
  readonly lastEventId?: string;
}

// =============================================================================
// Middleware Types
// =============================================================================

/** Request context passed through middleware */
export interface RequestContext {
  readonly path: string;
  input: unknown;
  readonly type: ProcedureType;
  meta?: Record<string, unknown>;
  readonly signal?: AbortSignal;
}

/** Response context from middleware */
export interface ResponseContext<T = unknown> {
  readonly data: T;
  readonly meta?: Record<string, unknown>;
}

/** Middleware function type */
export type Middleware = <T>(
  ctx: RequestContext,
  next: () => Promise<T>,
) => Promise<T>;

// =============================================================================
// Event Iterator Types
// =============================================================================

/** Async event iterator for subscriptions */
export interface EventIterator<T> extends AsyncIterable<T> {
  /** Stop the stream and clean up resources */
  return(): Promise<void>;
  /** Get the underlying async iterator */
  [Symbol.asyncIterator](): AsyncIterator<T>;
}

// =============================================================================
// Utility Types
// =============================================================================

/** Make all properties optional recursively */
export type DeepPartial<T> = T extends object
  ? { [P in keyof T]?: DeepPartial<T[P]> }
  : T;

/** Prettify type for better IntelliSense display */
export type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};
